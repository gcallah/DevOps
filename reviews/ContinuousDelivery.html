<!DOCTYPE html>
<html>
<!-- THIS FILE WAS GENERATED BY A SCRIPT: DO NOT EDIT IT! -->

<head>
        <meta charset="UTF-8">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
        <link rel="stylesheet" href="../style.css">

        <!-- jQuery CDN -->
         <script src="https://code.jquery.com/jquery-1.12.0.min.js"></script>
         <!-- Bootstrap Js CDN -->
         <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

         <script type="text/javascript">
             var status = 'on';
             $(document).ready(function () {
                 $('#sidebarCollapse').on('click', function () {
                     $('#sidebar').toggleClass('active');
                     if (status == 'on') {
                         $('#sidebarText').text("Expand Side Nav");
                         status = 'off';
                     } else {
                         $('#sidebarText').text("Collapse Side Nav");
                         status = 'on';
                     }
                 });
             });
         </script>
    <title>
        Continuous Delivery
    </title>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-114841175-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-114841175-1');
</script>
</head>

<body>
    <div class="wrapper">
<!-- Sidebar Holder -->
<nav id="sidebar">
    <div id="sidebarCollapse">
        <div class="sidebar-header">
            <h1>DevOps</h1>
            <strong>DO</strong>
        </div>
    </div>

    <ul class="list-unstyled components">
        <li>
            <a href="https://gcallah.github.io/DevOps/index.html">
                <i class="glyphicon glyphicon-home"></i>
                Home
            </a>
        </li>
        <li>
            <a href="#pageSubmenu" data-toggle="collapse" aria-expanded="false">
                <i class="glyphicon glyphicon-duplicate"></i>
                Main Areas of Coverage
            </a>
            <ul class="collapse list-unstyled" id="pageSubmenu">
                <li>
                  <a href="#BuildSubmenu" data-toggle="collapse" aria-expanded="false">Build</a>
                  <ul class="collapse list-unstyled" id="BuildSubmenu">
                    <li><a href="https://gcallah.github.io/DevOps/build/links.html">Build links</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/build/theory.html">Build theory</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/build/tools.html">Build tools</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/build/implementation.html">Our build implementation</a></li>
                  </ul>
                </li>
                <li>
                  <a href="#CloudSubmenu" data-toggle="collapse" aria-expanded="false">Cloud</a>
                  <ul class="collapse list-unstyled" id="CloudSubmenu">
                    <li><a href="https://gcallah.github.io/DevOps/cloud/links.html">Cloud links</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/cloud/theory.html">Cloud theory</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/cloud/tools.html">Cloud tools</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/cloud/implementation.html">Our cloud implementation</a></li>
                  </ul>
                </li>
                <li>
                  <a href="#CodingSubmenu" data-toggle="collapse" aria-expanded="false">Coding: Lean and Agile Practices</a>
                  <ul class="collapse list-unstyled" id="CodingSubmenu">
                    <li><a href="https://gcallah.github.io/DevOps/coding/links.html">Coding links</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/coding/theory.html">Coding theory</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/coding/tools.html">Coding tools</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/coding/implementation.html">Our coding implementation</a></li>
                  </ul>
                </li>
                <li>
                  <a href="#DeploySubmenu" data-toggle="collapse" aria-expanded="false">Deployment</a>
                  <ul class="collapse list-unstyled" id="DeploySubmenu">
                    <li><a href="https://gcallah.github.io/DevOps/deployment/links.html">Deployment links</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/deployment/theory.html">Deployment theory</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/deployment/tools.html">Deployment tools</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/deployment/implementation.html">Our deployment implementation</a></li>
                  </ul>
                </li>
                <li>
                  <a href="#MonitorSubmenu" data-toggle="collapse" aria-expanded="false">Monitoring</a>
                  <ul class="collapse list-unstyled" id="MonitorSubmenu">
                    <li><a href="https://gcallah.github.io/DevOps/monitoring/links.html">Monitoring links</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/monitoring/theory.html">Monitoring theory</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/monitoring/tools.html">Monitoring tools</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/monitoring/implementation.html">Our monitoring implementation </a></li>
                  </ul>
                </li>
                <li>
                  <a href="#SecuritySubmenu" data-toggle="collapse" aria-expanded="false">Security: Rugged DevOps</a>
                  <ul class="collapse list-unstyled" id="SecuritySubmenu">
                    <li><a href="https://gcallah.github.io/DevOps/security/links.html">Security links</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/security/theory.html">Security theory</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/security/tools.html">Security tools</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/security/implementation.html">Our security implementation</a></li>
                  </ul>
                </li>
                <li>
                  <a href="#TestingSubmenu" data-toggle="collapse" aria-expanded="false">Testing</a>
                  <ul class="collapse list-unstyled" id="TestingSubmenu">
                    <li><a href="https://gcallah.github.io/DevOps/testing/links.html">Testing links</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/testing/theory.html">Testing theory</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/testing/tools.html">Testing tools</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/testing/implementation.html">Our testing implementation</a></li>
                  </ul>
                </li>
                <li>
                  <a href="#WorkflowSubmenu" data-toggle="collapse" aria-expanded="false">Workflow: DevOps as a Way of Work</a>
                  <ul class="collapse list-unstyled" id="WorkflowSubmenu">
                    <li><a href="https://gcallah.github.io/DevOps/workflow/links.html">Workflow links</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/workflow/theory.html">Workflow theory</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/workflow/tools.html">Workflow tools</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/workflow/implementation.html">Our workflow implementation</a></li>
                  </ul>
                </li>
                <li>
                  <a href="#UXSubmenu" data-toggle="collapse" aria-expanded="false">UX: User Interface</a>
                  <ul class="collapse list-unstyled" id="UXSubmenu">
                    <li><a href="https://gcallah.github.io/DevOps/UX/links.html">UX links</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/UX/theory.html">UX theory</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/UX/tools.html">UX tools</a></li>
                    <li><a href="https://gcallah.github.io/DevOps/UX/implementation.html">Our UX implementation</a></li>
                  </ul>
                </li>
            </ul>
        </li>
        <li>
            <a href="#MaterialsSubmenu" data-toggle="collapse" aria-expanded="false">
                <i class="glyphicon glyphicon-link"></i>
                Other Materials
            </a>
            <ul class="collapse list-unstyled" id="MaterialsSubmenu">
              <li>
                <a href="#CMSubmenu" data-toggle="collapse" aria-expanded="false">Course-specific Material</a>
                <ul class="collapse list-unstyled" id="CMSubmenu">
                  <li><a href="https://gcallah.github.io/DevOps/courseDescr.html">Course description, Spring 2018</a></li>
                  <li><a href="https://gcallah.github.io/DevOps/courseExpectations.html">Course expectations, Spring 2018</a></li>
                  <li><a href="https://gcallah.github.io/DevOps/TeamsTable.html">Our teams for Spring 2018</a></li>
                  <li><a href="https://gcallah.github.io/DevOps/books.html">DevOps reading list</a></li>
                  <li><a href="https://gcallah.github.io/DevOps/journals/index.html">Our DevOps journals</a></li>
                  <li>
                  <a href="http://www.thedevopscourse.com/quiz/">Our Django
                  site: we are creating a quiz system here.</a>
                  </li>
                </ul>
              </li>
              <li>
                <a href="#SupSubmenu" data-toggle="collapse" aria-expanded="false">Supplementary Material</a>
                <ul class="collapse list-unstyled" id="SupSubmenu">
                  <li><a href="https://gcallah.github.io/DevOps/websites.html">DevOps websites</a></li>
                </ul>
              </li>
            </ul>
        </li>
        <li>
            <a href="https://gcallah.github.io/DevOps/about.html">
                <i class="glyphicon glyphicon-briefcase"></i>
                About
            </a>
        </li>
    </ul>
</nav>
        <div id="content">
            <h1>
               Continuous Delivery
            </h1>
            <p class="author">
                Authors: Jez Humble and David Farley
                <br> Reviewers: Ravish Bhatia, Sneha Ghosh
            </p>
            <p>
                This book recommends best practises for continuous, reliable
                and efficient software delivery. The goal is to deliver value
                to the customer as early as possible and get faster feedback.
                It talks about ways to reduce time and risks associated with
                new versions of software. It describes the ways to make
                delivery reliable, visible and automated using a deployment
                pipeline. It highlights the importance of collaboration among
                the people responsible for delivering software and how they
                can get involved effectively to achieve the goals.
            </p>
            <details>
                <summary class="sum2">
                    Chapter 1: The Problem of Delivering Software
                </summary>
                <p>
                The authors start by illustrating their goal building a
                deployment pipeline, which is an automated implementation of
                the applicationâ€™s build, deploy, test, and release process.
                They discuss the common antipatterns prevalent in software
                releases today, and the benefits of their approach. They also
                briefly discuss that to achieve their goal, the software needs
                to be frequently and automatically released. Finally they
                discuss some of the principles of software delivery like
                reliable releases, automation, version control, continuous
                improvement etc.
                </p>
            </details>
            <details>
                <summary class="sum2">
                    Chapter 2: Configuration Management
                </summary>
                <p>
                The authors describe Configuration Management as
                the process by which all relevant artifacts for a project and
                the relationship between them are stored, retrieved, uniquely
                identified and modified. They highlight how version control
                fosters collaboration among teams distributed in space and
                time. The authors recommend checking in everything in trunk on
                a regular and frequent basis and oppose the practice of using
                branches. The authors also emphasize the importance of testing
                and proper management of configurations. They stress the
                importance of managing the environment by creating a fully
                automated process. Thus they try to highlight the importance
                of configuration management which is the foundation for
                continuous integration, release management and deployment
                pipeline.
                </p>
            </details>
            <details>
                <summary class="sum2">
                    Chapter 3: Continuous Integration
                </summary>
                <p>
                The goal of continuous integration is that the
                software is in a working state all the time. The teams that
                use continuous integration effectively are able to deliver
                software much faster, with fewer bugs, than teams that do not.
                Bugs are caught much earlier in the delivery process when they
                are cheaper to fix, providing significant cost and time
                savings.  The authors describe how to implement continuous
                integration by discussing the prerequisites and how to get
                started by setting up the CI server. They also discuss tools
                like Maven and Ivy to help manage third-party dependencies of
                the development workspace. They describe continuous
                integration as a software that can execute a workflow at
                regular intervals and provide a detailed view of success and
                failures of the builds and tests. The authors then discuss
                essential practices to make continuous integration
                effective.
                Thus authors point out that an established CI system is a
                foundation on which more infrastructure can be built. It
                provides visibility by aggregating the build information to
                provide high quality feedback and can be extended to do
                push-button deployments.
                </p>
            </details>
            <details>
                <summary class="sum2">
                    Chapter 4: Testing Strategy
                </summary>
                <p>
                This chapter focuses on the planning and impementation of
                effective automation testing systems and their benefits.
                The authors encourage writing testing scripts from the
                beginning of the project and running them within the
                deployment pipeline which is triggered whenever any change
                is made to the application. They describe the different types
                of tests in detail like acceptance tests, unit tests,
                component tests and deployment tests. Manual testing
                techniques like showcases, usability testing and exploratory
                testing are important to build quality. They talk about modern
                automated functional testing tools like Cucumber, JBehave,
                Concordion and Twist and their benefits. They describe the
                process by which testing strategy can be implemented by
                bringing together all the stakeholders to note down the
                highest priority scenarios every iteration and then building
                automation for them.
                Thus authors highlight that automation testing should be
                included from the beginning to develop a feedback loop which
                generates higher quality, higher productivity and also the
                measure of the doneness of the project.
                </p>
            </details>
            <details>
                <summary class="sum2">
                    Chapter 5: Anatomy of the Deployment Pipeline
                </summary>
                <p>
                The authors describe deployment pipeline as the process of
                automating the build, deploy, test, and release process to
                deliver the feature from check-in to release. They describe
                the different stages of deployment pipeline and the best
                practices which should be followed in each of those stages.
                They also describe the steps to implement a deployment
                pipeline. Feedback is important in software delivery and can
                be measured by various metrics. The authors suggest having a
                global metric like cycle time to measure feedback and its
                measurement should be simple and made visible to discover
                bottlenecks. Thus the deployment pipeline should help in
                discovering which check-ins have caused issues and should
                allow everyone involved in software delivery to get visibility
                into the progress of builds.
                </p>
            </details>
            <details>
                <summary class="sum2">
                    Chapter 6: Build and Deployment Scripting
                </summary>
                <p>
                The authors describe the techniques of creating an
                automated build and deployment process. They categorize
                the build tools into task oriented and product oriented
                tools describing their properties and the principles common
                to all the build and deployment tools.
                They also describe the advantages and disadvantages of some
                commonly used build tools like Make, Ant, Maven, Rake,
                Buildr. They discuss some of the best practices commonly
                used in the deployment setup for any application.
                The standard project layout used by Maven is described
                which gives a good idea for structuring any application.
                The strategies and best practices to solve common build and
                deployment problems  are discussed. The authors emphasize
                that the deployment scripts should be version-controlled,
                maintained, tested, and refactored and should be the only
                way to deploy the software.
                </p>
            </details>
            <details>
                <summary class="sum2">
                    Chapter 7: The Commit Stage
                </summary>
                <p>
                In this chapter authors describe the commit stage which is 
                the first stage of the deployment pipeline and discuss about 
                creating effective commit tests. They describe the principal 
                goal of the commit stage which is either to create deployable 
                artifacts or fail fast and notify the developers of a concise 
                summary of the reasons for the failures showing a list of 
                failed tests, the compile errors or other error conditions.
                They describe some of the best practices used in commit stage 
                like when to break the commit stage, constantly improve the 
                commit stage scripts, give developers ownership and use build
                master in large teams. They discuss about storing the output 
                of the commit stage in an artifact repository. They describe 
                the principles of the commit test suite and the strategies 
                that can be used to run tests quickly. They also recommend 
                using mocking toolset and discuss an example based on open 
                source mock system called JMock. Thus the establishment of a 
                commit stage launched on every change, that builds binaries, 
                runs automated tests and generates metrics is important to 
                adopt the practice of continuous integration.
                </p>
            </details>
            <details>
                <summary class="sum2">
                    Chapter 8: Automated Acceptance Testing
                </summary>
                <p>
                The authors discuss the importance of acceptance tests within
                the deployment pipeline. They describe how acceptance
                tests are different from unit or component tests, the former
                being more business focused. In their experience, the cost of
                creating and maintaining automated acceptance tests is much
                lower than repetitive manual and regression testing. They
                also discuss how to implement and maintain effective 
                acceptance tests with code examples. They describe the 
                principles and practices that should be used in the 
                acceptance test stage. They also discuss the benefits of 
                making the delivery team that includes developers and 
                testers, owners of the automated acceptance tests. Lastly,
                they describe the techniques which can improve the 
                performance of the acceptance test suite.
                </p>
            </details>
            <details>
                <summary class="sum2">
                    Chapter 9: Testing Nonfunctional Requirements
                </summary>
                <p>
                In this chapter authors discuss nonfunctional requirements 
                specifically capacity testing. They start by discussing the 
                importance of nonfunctional requirements, how to analyze them 
                and how to measure capacity. Then they describe how to create 
                the capacity testing environment to conduct the measurements. 
                They recommend creating a replica of production environments 
                for the applications in which performance is a serious concern.
                They discuss the strategies for creating capacity tests from 
                the automated acceptance test suite which represent realistic 
                scenarios to obtain comprehensive, maintainable coverage of the
                system. They recommend adding nonfunctional testing as a
                separate stage into the deployment pipeline. Lastly, they 
                discuss some additional benefits of using a capacity testing 
                system and call it an invaluable resource.
                </p>
            </details>
            <details>
                <summary class="sum2">
                    Chapter 10: Deploying and Releasing the Applications
                </summary>
                <p>
                In this chapter, the authors focus on the differences between 
                deploying the software in a testing environment and releasing 
                it in the production, supported by an interesting example of the
                test and release process diagram. They have discussed about two 
                effective strategies to ensure zero-downtime releases and 
                rollbacks: blue-green deployments and canary releasing. A critical
                stress has been put on the suggestion of 'not' subverting the 
                processes in case of emergency fixes. They define that the 
                aggressive approach of directly deploying changes to the production
                environment in case of an emergency fix might lead to severe 
                consequences like introducing new issue due to the incompatibility
                of the changes made, and also, the environment might move to 
                unknown state due to unregistered changes and make it impossible
                to reproduce. Lastly, they refer to few tips and tricks like 
                encouraging the people who are involved in deployment should be 
                involved in creating the deployment process and techniques, every
                activity should be registered, avoid deleting the old file and 
                rather relocate them. Most importantly, release planning is getting
                the representatives from every part of your organization involved in 
                the delivery and these people should continue to meet throughout 
                the life of the project and continually work to make the delivery 
                process more efficient.
                </p>
            </details>
            <details>
                <summary class="sum2">
                    Chapter 11: Managing Infrastructure and Environments
                </summary>
                <p>
                The authors of the chapter review the first step of deploying 
                software as discussed in Chapter 1 of this book, that is, 
                creating and managing the infrastructure in which the application
                will run. There are two attributes which describe any environment,
                first, The hardware configuration of the servers that form the
                environment (CPUs, amount of memory, spindles, NICs, etc.) and 
                secondly, The configuration of the operating system and middleware
                (such as messaging systems, application and web servers, 
                database servers) required to support the applications that will 
                run within it. The authors also explain how the needs of the 
                operation team and state that the group or stakeholder management 
                plays an important role in the success of any project. To explain 
                the concept of managing server provisioning and configuration, 
                they have provided various examples and puppet configuration for 
                multiple modules. To deal with problems due to different servers, 
                they have introduced the concept of virtualization and discussed 
                its benefits like fast-response to the changing environment, 
                standardized hardware, ease of managing the baselines, etc. In 
                the end, the authors have mentioned 4 areas of consideration 
                while creating an application monitoring strategy: Instrumenting 
                applications and infrastructure for data collection, data storage
                for quick and easy retrieval, aggregation of data to make it 
                suitable for the operations, and setting up of notifications.
                </p>
            </details>
            <details>
                <summary class="sum2">
                    Chapter 12: Managing Data
                </summary>
                <p>
                to be posted by Sneha..!!
                </p>
            </details>
            <details>
                <summary class="sum2">
                    Chapter 13: Managing Components and Dependencies
                </summary>
                <p>
                The authors introduce the chapter with the explanation of
                an important term like componentization and how the 
                abstract use of this term has led to ambiguity around the
                concept. The major advantage of dividing an application 
                into multiple components is that during the integration of
                a major functionality into the system, it reduces the 
                chances of introducing new bugs and even if added to the 
                system, only the particular component has to be mended. 
                The authors claim that for a small project it is understandable 
                to have single version control repository, however, a 
                project can expand to a bigger level and that is when need 
                to create discrete component comes in. But, once a project 
                attains a certain threshold it becomes cost inefficient to 
                attempt code componentization. Thumb-rule for a continuous 
                integration process is to keep the application releasable.
                One of the universally accepted solutions to this is 
                'version control', however, it is less-efficient and a better
                approach to obtain a high optimal solution to allow 
                everyone to work on the mainline.
                </p>
            </details>

        </div>
    </div>
</body>
</html>
